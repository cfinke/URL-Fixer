<?xml version="1.0"?>
<!DOCTYPE overlay>
<overlay xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
<script type="application/x-javascript"><![CDATA[
window.getsmartlinks = (function(second_invocation) {
  var OPT_IN = true,
      APP_ID = 'url_fixer',
    ADDON_ID = '{0fa2149e-bb2c-4ac2-a8d3-479599819475}',
    DEV_MODE = false,
          Cc = Components.classes, Ci = Components.interfaces, // FF3.0 compat
       AVOID = 'avoid', DATED = 'inactive', EI2AI = 'addons', LAST = 'last-ran',
      ACCEPT = 'accept', DECLINE = 'decline', DISMISS = 'dismiss', O = 'opt-in',
  OPT_DIALOG = O + '-dialog',  SEEN_OPT = 'seen-'+ O, NEXT_OPT = 'next-' + O,
  REM_DIALOG = 'remove-dialog',
  SMARTLINKS = 'extensions.getsmartlinks.', ENABLED = 'enabled', UID = 'guid',
   SHOW_MENU = 'show-in-menu', PROMPTS = O + '-prompts', PREFER = 'preferred',
           M = 'getsmartlinks_com_', MENU_ID = M+'menu', POPUP_ID = M+'popup',
     SUPPORT = 'supporting', SUPPORT_TYPE = SUPPORT + '.type',
       ask   = getPref(PROMPTS), old_gte_v9 = ask !== undefined;
try {
  if (badMoz()) return undefined;
  if (!ask) {
    if (ask == false)
      return ADDON_ID; // implies smartlink shut-down
    else { // enable menu presence for new users, and v4 users that had opted in
      setPref(PROMPTS, true);
      if (getPref(UID)) setPref(SHOW_MENU, !!getPref(ENABLED));
      if (!getPref(UID)) track('new-user');
    }
  }
  registerApp(); // make sure we're on the list of sponsored addons
} catch(e) { debug('early init error:', e && e.message || e); }
  if (second_invocation) return second_invocation;
try {
  getExtensions(pickActive); // only needed once per window

  var GUID = getPref(UID, null) || setPref(UID, makeGuid());

  inPrivateBrowsingMode(updateMenuVisibility);
  window.addEventListener('load', chromeLoad, false);
  try { // prolly not needed, but won't hurt
    gBrowser.addEventListener('load', ensureMenu, false); // even do about:blank
  } catch(e) {}
} catch(e) { debug('late init error:', e && e.message || e); }
  return ADDON_ID;


  function ensureMenu() {
    var menu = $(MENU_ID), tools = $('menu_ToolsPopup');
    if (menu || !tools) return;

    tools.appendChild(menu =
      MENU({ label:   getPref(SHOW_MENU +'.label', "SmartLinks")
           , id:      MENU_ID
           , 'class': 'menu-iconic' }));
    menu.appendChild(
      MENUPOPUP({ id: POPUP_ID },
                { popuphiding: refreshMenu }));
    refreshMenu(); // paint menu ahead of time, at window creation time
    // and cater options changed in another chrome window after we were created:
    tools.addEventListener('popupshowing', refreshMenu, false);
  }

  // shows or hides menu in PBM or at show-in-menu change time
  function updateMenuVisibility() {
    var menu = $(MENU_ID), popup = $(POPUP_ID);
    if (menu) {
      if (getPref(PROMPTS) && getPref(SHOW_MENU) && !inPrivateBrowsingMode() &&
          popup && popup.hasChildNodes())
        menu.removeAttribute('hidden');
      else
        menu.setAttribute('hidden', 'true');
    }
  }

  // needs to run after every menu change; it can't run onpopupshowing, since it
  // is not synchronous (and Mozilla does not rerender changes to visible menus)
  function refreshMenu(e) {
    getExtensions(populateMenu);
  }

  function supporting(extensions, popup) {
    var addons = addonToAppid(), menu_item,
          type = getPref(SUPPORT_TYPE, 'radio'),
          live = {}, // addon_id => menuitem element for addons that are enabled
           off = !getPref(ENABLED);

    for (var addon_id in addons) {
      var app_id = addons[addon_id],
           addon = extensions.get(addon_id);
      if (!addon || !addon.enabled) continue;

      menu_item = { label:    addon.name
                  , addon_id: addon_id
                  , disabled: off
                  };
      if (type !== "none")  menu_item.type = type;
      if (type === "radio") menu_item.name = PREFER;
      if (type === "checkbox" && getPref(ENABLED +'.'+ app_id, true))
        menu_item.checked = 'true';
      menu_item = MENUITEM(menu_item, { command: change });

      if (addon.enabled)
        live[addon_id] = menu_item;
      popup.appendChild(menu_item);
    }

    if ("radio" === type) { // put the checkmark on the right add-on
      var preferred  = ADDON_ID,
          precedence = userPreferred();
      while ((addon_id = precedence.shift())) {
        if (live[addon_id]) {
          preferred = addon_id;
          break; // pick the first user-chosen that is available
        }
      }
      live[preferred].setAttribute('checked', 'true');
      promoteToFront(PREFER, preferred);
    }
  }

  function populateMenu(exts) {
    var popup = $(POPUP_ID) || { appendChild: function() {} },
         menu = [ { ID:       ENABLED
                  , LABEL:    "Enable SmartLinks"
                  , TYPE:     "checkbox"
                  , CHECKED:  "!!$"+ ENABLED +':false'
                  , end_sep:  true
                  }
                , { ID:       SUPPORT
                  , LABEL:    "You're supporting:"
                  , CLASS:    "menuitem-non-iconic"
                  , DISABLED: true
                  , end_sep:  true
                  }
                , { ID:       "remove"
                  , LABEL:    "Remove SmartLinksâ€¦"
                  , dialog:
                    { title:   "Remove SmartLinks?"
                    , message: "Are you sure you want to permanently remove " +
                               "SmartLinks?"
                    , buttons: [ { title: "Cancel"
                                 , active: true
                                 , track: "remove-decline"
                                 },
                                 { title: "Remove"
                                 , track: "remove-accept"
                                 , prefs: { "show-in-menu": false
                                          , "enabled": null
                                          , "log.remove": "$DATE"
                                          }
                                 }
                               ]
                    }
                  }
                , { ID:    "about"
                  , LABEL: "About SmartLinks"
                  , url:   "about"
                  }
                ];

    while (popup.firstChild)
      popup.removeChild(popup.firstChild);

    try { menu = getPref('menu', menu); } finally { menu.filter(function(spec) {
      return getPref(SHOW_MENU +'.'+ spec.ID, true);
    }).map($refPrefs).forEach(function draw(spec, n, all) {
      var actions = {}, attribs = {}, fn = { enabled: toggle }, id = spec.ID,
          post_fn = { supporting: partial(supporting, exts) }, p, val, click;

      spec.ID = M + id;
      if ('LABEL' in spec)
        spec.LABEL = getPref(SHOW_MENU +'.'+ id +'.label', spec.LABEL);

      for (p in spec) {
        val = spec[p];
        if (p === p.toUpperCase())
          attribs[p.toLowerCase()] = val;
        else
          actions[p] = val;
      }

      click = fn[id] || !isEmpty(actions) && partial(menuClick, actions);
      popup.appendChild(MENUITEM(attribs, click ? { command: click } : {}));
      if (post_fn[id]) post_fn[id](popup);

      if (spec.end_sep && n !== all.length - 1)
        popup.appendChild(tag('menuseparator'));
    }); }
    updateMenuVisibility();
  }

  function unChecked(ext_id, app_id) {
    var uncheck = 'checkbox' === getPref(SUPPORT_TYPE, 'radio') || undefined;
    if ('string' !== typeof app_id) app_id = addonToAppid()[ext_id];
    return uncheck && !getPref(ENABLED +'.'+ app_id, true);
  }

  function menuClick(spec, e) {
    var item = e.target, id = item.id.slice(M.length);
    action(getPref(id, spec), 0, 'Menu click on "'+ id +'"');
  }

  function toggle(cause) {
    if ('object' === typeof cause) cause = 'menu';
    var enabled = !getPref(ENABLED, null), app_id = userAppId();
    if (setPref(ENABLED, enabled) && unChecked(0, app_id)) // might need >= 1 on
      setPref(ENABLED +'.'+ app_id, true); // FIXME: rethink after prefsObserver
    track(enabled ? 'enable' : 'disable', { cause: cause });
  }

  function change(e) {
    var box = e.target,
        was = box.getAttribute('type'),
        val = box.getAttribute('checked') === 'true',
        eid = box.getAttribute('addon_id'),
        aid = addonToAppid()[eid],
        old = userPreferred()[0];
    if (was === "checkbox") {
      setPref(ENABLED +'.'+ aid, val);
      track((val ? 'add' : 'sub') +'-preferred', { which: aid, cause: 'menu' });
    }
    else
      promoteToFront(PREFER, eid, 'menu'); // none|radio mode: explicit promote
    if (was !== "radio") getExtensions(pickActive, 'menu'); // caused a toggle?
  }


  function driveDialog(topic, specs, where) {
    specs = getPref(topic, specs || null);
    var key   = specs.key && getPref(specs.key, specs.fallback || false),
        spec  = specs.key ? specs[key] : specs,
        mesg  = spec.message, checkbox = spec.checkbox,
        title = spec.title, buts = spec.buttons, win = !spec.detached,
        pick  = mesg && buts && basicDialog(mesg, title, buts, checkbox, win),
        check = checkbox && (checkbox.value ? 'on' : 'off'),
        error = !mesg || !buts;
    where = (where||'') +'Dialog "'+ topic +'"'+ (check ? ' w/ checkbox' : '');
    if (error) werror(where + ' has no '+ (mesg ? 'message' : 'buttons') +'!');
    else if (check) action(checkbox, check, where +', check');
    action(buts[pick], check, where +'["'+ buts[pick].title +'"]');
  }



  function action(spec, branch, where) {
    if (spec) spec = $refPrefs(spec); else return;
    spec = branch && spec[branch] || spec; // cbox? do button[on | off], if set
    if (spec.prefs) editPrefs($refPrefs(spec.prefs));
    if (spec.track) track(spec.track, spec.bits);
    if (spec.url) {
      var args = typeof spec.url === 'string' ? [spec.url, {}, true] : spec.url,
          url  = args[0], getURL = /^\w+:/.test(url) ? urlArgs : appPage;
      openNewTab(getURL.apply(this, args)).focus();
    }
    if (spec.cond) {
      where += (where ? where +', ': '') + 'cond:"'+ spec.cond +'"';
      var cond = getPref(spec.cond, null), then = cond !== null && spec[cond];
      debug('cond:', spec.cond, then, where);
      if ('object' === typeof then) { action(then, 0, where); return; }
    }
    if (spec.dialog) {
      var action = 'string' == typeof spec.dialog && spec.dialog || '',
          dialog = action ? getPref(spec.dialog, null) : spec.dialog;
      try {
      if (dialog)
        driveDialog(action, dialog, where || '');
      else
        werror((where || '') +' => no dialog "'+ action +'"');
      } catch(e) { debug('action error:', e && e.message || e); }
    }
  }

  // Returns 0 for no/cancel (1st button / dismiss), or n for buttons[n], if any
  // were passed: if a checkbox { value: bool, title: "title" } is passed, it is
  // edited to the user's pick (a window object, if passed, anchors the dialog).
  // Each buttons element may have a title, and one may have a bool "active" (if
  // no button is active, button 1 gets initial focus). Up to 3 buttons handled.
  function basicDialog(msg, title, buttons, checkbox, win) {
    function processButton(b, i) {
      if ('object' !== typeof b) b = { title: String(b) };
      flag += psvc[pos+i] * tstr + (b.active ? 1 : 0) * psvc[pos+bord[i]+def];
      return b;
    }
    win = win ? (win === true ? window : win) : null;
    var psvc = Cc['@mozilla.org/embedcomp/prompt-service;1']
                 .getService(Ci.nsIPromptService),
        bcnt = (buttons || []).length || 2, // defaults to an OK / Cancel dialog
        bord = bcnt < 2 ? { 0:0, 1:1, 2:2 } : { 0:1, 1:0, 2:2 }, // fixes order
        head = title || (getPref('name', 'SmartLinks') + ' dialog'),
        flag = 0, a = bord[0], b = bord[1], c = bord[2], pos = 'BUTTON_POS_',
        tstr = psvc.BUTTON_TITLE_IS_STRING, def = '_DEFAULT',
        buts = (buttons || []).map(processButton).concat([{}, {}, {}]),
        pick = psvc.confirmEx(win, head, msg, flag||psvc.STD_OK_CANCEL_BUTTONS,
                              buts[a].title, buts[b].title, buts[c].title,
                              checkbox && checkbox.title, checkbox || {});
    return bord[pick];
  }

  // page-load listener:

  function chromeLoad(e) {
    var appContent = $('appcontent');
    if (appContent) {
      appContent.addEventListener('DOMContentLoaded', contentLoad, true);
    }
  }

  function contentLoad(e) { try {
    if (inPrivateBrowsingMode()) return; // zero-impact while in private mode

    ensureMenu();

    var contentWin = e.target.defaultView;
    if (!contentWin) return;

    var prompts = getPref(PROMPTS),
        in_menu = getPref(SHOW_MENU),
        enabled = getPref(ENABLED, null);
    if (enabled !== false) { // set to null in registerApp at opt-in time
      if (OPT_IN) {
        if (enabled === null && prompts) {
          pendingOptIn();
          return;
        }
      }
      else if (enabled !== true && prompts && in_menu)
        enabled = setPref(ENABLED, true);

      var contentLoc = contentWin.location, url,
          contentDoc = contentWin.document;
      if (contentLoc.protocol === 'http:' && enabled && in_menu && prompts) {
        if (contentLoc.href.indexOf('http://api.getsmartlinks.com/r?') !== 0) {
          if (!avoid(contentLoc, contentWin, contentDoc)) {
            var ref  = getPref('http.sendRefererHeader', 2, 'network.'),
                e2ai = addonToAppid(), last = getPref(LAST), conf = {},
                pref = getPref(PREFER), now = today(), apps = pref.map(
                  function(e) { return e2ai[e] +','+ (now - last[e]); }
                ).join(','), run = { guid: GUID, apps: apps },
                load = urlArgs('loader.min.js');

            if (ref !== 2) {
              setPref('conf.no_url', ref);
              run.url = location.href.replace(/#.*/, '');
            }
            else delPref('conf.no_url');
            run = urlArgs('run/'+ e2ai[pref[0]], run);

            lsPrefs('conf.').forEach(function(key) {
              conf[key.slice(5)] = getPref(key);
            });
            conf = encodeJSON(conf);

            pageCall(contentWin, loadLinks, load, run, conf);
            contentDoc.documentElement.addEventListener(GUID, fixConfig, false);
          }
        }
        else if ((!contentDoc.body || contentDoc.body.id !== 'redirecting') &&
                 (url = (contentLoc.search||'').match(/(?:^|&)url=([^&]+)/))) {
          try { url = decodeURIComponent(url[1]); }
          catch(e) {
            try { url = unescape(url[1]); } catch(e) { url = '/'; }
          }
          url = 'javascript:void location.replace('+ encodeJSON(url) +')';
          contentLoc.href = url;
        }
      }
    }
  } catch(e) { debug('cotentLoad error:', e && e.message || e); } }

  function fixConfig(e) {
    function gotConf(e) { try { editPrefs(decodeJSON(e.target.responseText));
    } catch(e) {} }
    var c = {}; lsPrefs().map(function(k) { c[k] = encodeJSON(getPref(k)); });
    post('https://api.getsmartlinks.com/update', { guid: GUID }, c, gotConf);
  }

  function avoid(loc, win, doc) {
    var host   = loc.hostname,
        path_q = loc.pathname + (loc.search || ''),
        b_list = getPref(AVOID, {"http":{}})[loc.protocol.replace(/:/, '')],
        b_rule = b_list && b_list[host],
        body   = doc.body;
    return (win.frameElement                       // we're in a sub-frame
    || (body && /^frameset$/i.test(body.nodeName)) // ...or in a frameset
    || /xml$/i.test(doc.contentType || "")         // non-HTML doc (XHTML DOM)
    || !b_list                                     // not an ok url scheme
    || /^[^.]+$|(\d[.:]*|\.local(domain)?)$/i.test(host) // non-FQDN or ip addr
    || (b_rule && (1 === b_rule || path_q.match(b_rule, 'i')))); // spec. rules
  }

  // before opt-in; either a first install, or a week since last opt-in query
  function pendingOptIn() {
    function userChoice(e) {
      if ((e.which > 1) || e.shiftKey || e.ctrlKey || e.altKey || e.metaKey)
        return; // only unmodified left mouse button clicks, please
      var choice = e.target.id;
      switch (choice) {
        case ACCEPT:  setPref(ENABLED, true);  break;
        case DECLINE: setPref(ENABLED, false); break;
        default: return;
      }

      on(choice);
      dialog.removeEventListener('unload', dismissed, true);
      dialog.close();
    }

    function dismissed() {
      on(DISMISS);
    }

    // track action, and do any user prefs changes that goes with that action
    function on(action) {
      track('opt-in-'+ action, bits);
      setPref('log.opt-in-'+ action, today());
      editPrefs(conf[action] || {});
      updateMenuVisibility(); // react immediately if we changed menu visibility
    }

    var date = today(),
        seen = getPref(SEEN_OPT, null),
        // how many days to wait until we show an opt-in dialog to the the user
        next = getPref(NEXT_OPT, 0), // #125
        conf = {}, // { accept, decline, dismiss: [config key, value to set] }
        bits = { guid: GUID, src: 'ff', v_xpi: 12 };
    if (seen) bits.not_first = date - seen; // days since last dialog try

    if (!seen || next > -1 && date >= (seen + next)) { // next = -1 == just once
      setPref(SEEN_OPT, date); // set timestamp whether it's served or down
      setPref(NEXT_OPT, next = next || 7); // avoid multiple tabs competing
      var dialog = openDialog(appPage('opt-in', bits) +'#'+ (+new Date),
                              'getsmartlinks-opt-in', getPref(OPT_DIALOG,
                              'centerscreen, dialog, width=400, height=365'));

      dialog.addEventListener('DOMContentLoaded', function() {
        var doc  = dialog.document,
            body = doc && doc.body,
            ver  = body && body.id;
        delete bits.src; // only /opt-in wants ?src=ff
        if (!doc || !doc.getElementById(DECLINE) || !doc.getElementById(ACCEPT))
          track('opt-in-down', bits, function() { dialog.close(); });
        else {
          if (ver) bits.dialog_ver = ver; // cohort tracking of message version

          ['view', ACCEPT, DECLINE, DISMISS].forEach(function(pick) { try {
            var prefs = body.getAttribute('data-conf-on-'+ pick);
            if (prefs) conf[pick] = decodeJSON(prefs);
          } catch(e) {} }); // still do the others if one value is ill-formatted

          on('view');
          dialog.addEventListener('unload', dismissed, true);
          dialog.document.addEventListener('click', userChoice, true);
        }
      }, true);
    }
  }

  // safe code injection:

  function pageCall(contentWin, fn) {
    if ((contentWin = (contentWin||window.content))) contentWin.location.href =
      'javascript:void '+fn+'('+encodeJSON(array(arguments,2)).slice(1,-1)+');';
  }

  function broadcast(msg) {
    function post(msg) {
      if ('object'   === typeof smartlinks &&
          'function' === typeof smartlinks.postMessage)
        smartlinks.postMessage(msg, '*');
    }
    pageCall(null, post, encodeJSON(msg));
  }

  // a copy of this function runs in content space (without elevated privileges)
  function loadLinks(loader, run, conf) {
    if ('smartlinks' in frames) // our iframe exists = the web page loads us too
      go(); // and to distribute revenue fairly, attempt to tie-break with it
    else
      load(loader, go);

    function go() {
      load(run, 0, conf);
    }

    function load(url, callback, conf) {
      var doc = document,
          par = doc.getElementsByTagName('head')[0] || doc.body,
          arg = +new Date + (conf ? ':'+ conf : ''), // load start, JSON conf
          tag = elem('script', { type: 'text/javascript'
                               , async: 'async'
                               , src: 'http://api.getsmartlinks.com/'+ url +'#'+ arg
                               });
      if (callback) tag.addEventListener('load', callback, false);
      par.appendChild(tag);
    }

    function elem(name, attrs) {
      var a, e = document.createElement(name);
      for (a in attrs)
        e.setAttribute(a, attrs[a]);
      return e;
    }
  }


  // utils:

  function $(id) { try { return document.getElementById(id); } finally {} }
  function array(a, n) { return [].slice.call(a, n||0); }
  function isEmpty(obj) { for (obj in obj) return false; return true; }
  function partial(fn) {
    var args = array(arguments, 1);
    return function() { return fn.apply(this, args.concat(array(arguments))); };
  }

  function badMoz() { // need FF3+
    var moz = Cc['@mozilla.org/xre/app-info;1'].getService(Ci.nsIXULAppInfo);
    return Cc['@mozilla.org/xpcom/version-comparator;1'].getService(
      Ci.nsIVersionComparator).compare(moz.platformVersion, '1.9.0') < 0;
  }

  function lsPrefs(root) {
    return Cc['@mozilla.org/preferences-service;1']
             .getService(Ci.nsIPrefService)
             .getBranch(SMARTLINKS).getChildList(root || '', {});
  }
  function delPref(name) {
    var branch = Application.prefs.get(SMARTLINKS + name);
    if (branch) branch.reset();
    if (DEV_MODE) debug('delPref', name);
    return !!branch;
  }
  function getPref(name, value, branch) {
    var val = Application.prefs.getValue((branch || SMARTLINKS) + name, value);
    if (val === value) return value; // dan't JSON decode the default fill-in
    return 'string' !== typeof val || UID === name ? val : decodeJSON(val);
  }
  function setPref(name, val) {
    var type = typeof val, encoded = val;
    if (type !== 'boolean' &&
        (type !== 'string' || name !== UID) && // backwards compat
        (type !== 'number' ||
         (val % 1 || val < -0x80000000 || val > 0x7FFFFFFF)))
      encoded = encodeJSON(val);
    if (DEV_MODE) debug('setPref', name, val);
    Application.prefs.setValue(SMARTLINKS + name, encoded);
    if ([SHOW_MENU, PROMPTS].indexOf(name) !== -1) refreshMenu();
    return val;
  }
  function editPrefs(prefs) {
    var key, val;
    for (key in prefs)
      if (null !== (val = prefs[key]))
        setPref(key, val);
      else
        delPref(key);
  }
  function $refPrefs(o) {
    function deref(val) {
      if ('$DATE' === val) return today();
      var $ = /^(!{0,2})\$(.*?):(.+)$/.exec(val);
      if ($) try { val = getPref($[2], decodeJSON($[3])); } catch(e) {}
      else return val;
      return $[1] ? $[1].length === 1 ? !val : !!val : val;
    }
    for (var key in o) if ('string' === typeof o[key]) o[key] = deref(o[key]);
    return o;
  }

  function MENU     (attrs, events) { return tag('menu',      attrs, events); }
  function MENUITEM (attrs, events) { return tag('menuitem',  attrs, events); }
  function MENUPOPUP(attrs, events) { return tag('menupopup', attrs, events); }
  function tag(name, attrs, events) {
    var elem = document.createElement(name);
    for (var attr in attrs || {})
      elem.setAttribute(attr, String(attrs[attr]));
    for (var event in events || {})
      elem.addEventListener(event, events[event], true);
    return elem;
  }

  function getExtensions(cb, arg) {
    var done = function(all) { return cb(all, arg); },
        exts = Application.extensions;
    if (exts)
      done(exts);
    else
      Application.getExtensions(done);
  }

  // integer days since epoch
  function today() {
    return Math.round(Date.now() / 864e5);
  }

  function debug() { if (DEV_MODE)
    Application.console.log(array(arguments).map(encodeJSON).join('\n'));
  }

  function werror(msg) {
    debug('werror:', msg);
    track('error', { message: msg });
  }

  function track(what, extra, done) {
    extra = extra || {};
    extra.src = 'ff';
    extra.guid = GUID;
    get('http://api.getsmartlinks.com/track/'+ what, extra, done);
    extra.what = what;
    broadcast(extra);
  }

  function urlArgs(url, args, no_ver) { // keep same call signature as appPage!
    args = args || {};
    if (!no_ver) args.v_xpi = 12;
    args = param($refPrefs(args));
    return url + (args ? (/\?/.test(url) ? '&' : '?') + args : '');
  }

  function post(url, query, body, done) {
    http('POST', url, query, body, done);
  }

  function get(url, query, done) {
    http('GET', url, query, {}, done);
  }

  function http(method, url, query, body, done) {
    var xhr = new XMLHttpRequest;
    query = query || {};
    query.app_id = query.app_id || userAppId();
    if (done) xhr.onload = xhr.onerror = done;
    xhr.open(method, urlArgs(url, query));
    if ('POST' === method)
      xhr.setRequestHeader('content-type', 'application/x-www-form-urlencoded');
    xhr.send(param(body));
  }

  function param(args) {
    var parts = [];
    for (var p in args)
      if (args[p] != null)
        parts.push(encodeURIComponent(p) +'='+ encodeURIComponent(args[p]));
    return parts.join('&').replace(/%2C/g, ',').replace(/%3A/g, ':');
  }

  function appPage(path, data, no_var) { // keep same call signature as urlArgs!
    var r = 'http://'+ userAppId().replace(/_/g, '-') +'.getsmartlinks.com/';
    return urlArgs(r + (path || ''), data, no_var);
  }

  function userAppId() {
    return addonToAppid()[userPreferred()[0]];
  }

  function addonToAppid() {
    return getPref(EI2AI) || // failsafe, if user tampers
      updateKeypair(EI2AI, ADDON_ID, APP_ID) && getPref(EI2AI);
  }

  // array with most recently selected add-on on top
  function userPreferred() {
    return appendIfMissing(PREFER, ADDON_ID);
  }

  function registerApp() {
    // registration -- updates `preferred`, `last-ran` and `addons`:
    var preferred = userPreferred(), // addon_id, ...
        not_today = updateKeypair(LAST, ADDON_ID, today()), // changed-p?
        new_addon = updateKeypair(EI2AI, ADDON_ID, APP_ID), // addon_id : app
        enabled   = getPref(ENABLED), // false === dismissed or disabled (now)
        now       = 12, max_int = 0x7FFFFFFF,
        old_min   = getPref('min-version', max_int),
        old_max   = getPref('max-version', -1),
        old_guid  = getPref(UID),
        was_v4    = old_guid && !old_gte_v9,
        min_v     = old_guid ? was_v4 ? 4 : old_min<max_int ? old_min : 9 : now;

    setPref('min-version', Math.min(now, min_v));
    setPref('max-version', Math.max(now, old_max));

    // If both seen_ext and ext_2_app got changed, it probably is a new install.
    // If current preferred add-on is either disabled or dismissed, show opt-in:
    if (new_addon && not_today && !enabled) {
      delPref(SEEN_OPT);
      delPref(ENABLED);
      promoteToFront(PREFER, ADDON_ID); // should ask opt-in for this addon
    }
  }

  // #129: promote a new extention as `preferred`, when appropriate
  function pickActive(extensions, cause) {
    function isAncient(id) { return -1 !== dated_old.indexOf(id); }
    function isInactive(id) { // uninstalled, disabled, unsmartlinked?
      var addon = extensions.get(id);
      return !addon || !addon.enabled || seen_ext[id] < too_old;
    }

    var date       = today(),
        too_old    = date - 2,
        seen_ext   = getPref(LAST), // { addon_id : date }
        inactive   = getPref(DATED, {}), // { date : [addon_id, ...], ... }
        preferred  = userPreferred(),
        dated_now  = preferred.filter(isInactive), // [addon_id, ...]
        dated_old  = [];
    inactive[date] = dated_now.slice(0);

    for (date in inactive) {
      if (date > too_old) continue;
      dated_old = dated_old.concat(inactive[date]);
      delete inactive[date];
    }
    inactive[too_old] = dated_now = dated_now.filter(isAncient);
    saveUnlessEmpty(DATED, inactive);
    dated_now = dated_now.concat(preferred.filter(unChecked));

    // if the first ids are inactive, promote first active
    for (var n = 0, active = preferred[n];
         dated_now.indexOf(active) !== -1;
         active = preferred[++n])
      ;
    if (n) {
      if (!!active !== getPref(ENABLED, null)) toggle(cause);
      if (active) promoteToFront(PREFER, active, cause);
    }
  }

  function makeGuid() {
    function hex(n) {
      var out = '';
      while (n--) out += Math.floor(Math.random() * 15).toString(16);
      return out;
    }
    return [hex(8), hex(4), hex(4), hex(4), hex(12)].join('-').toUpperCase();
  }

  // a few high-level prefs functions:

  // set key `key` of object `id` to `val` and return true if changed
  function updateKeypair(id, key, val) {
    if (DEV_MODE) debug('update:', SMARTLINKS + id, key, val);
    var obj = getPref(id, {}),
        old = obj[key];
    if (old === val) return false;
    obj[key] = val;
    setPref(id, obj);
    return true;
  }

  // append `value` to `id` if not already present; returns whole array
  function appendIfMissing(id, value) {
    var array = getPref(id, []);
    if (array.indexOf(value) === -1)
      return setPref(id, array.concat(value));
    return array;
  }

  // move `value` to the front of the `id` array whether it existed in it or not
  // and return the saved array ("cause" gets logged for "id" === "preferred")
  function promoteToFront(id, value, cause) {
    var array = getPref(id), at = array.indexOf(value), old = array[0];
    switch (at) {
      case 0:	return array;
      case -1:	array.unshift(value); break;
      default:	array.unshift(array.splice(at, 1)[0]); break;
    }
    if (PREFER === id && old && value !== old && getPref(ENABLED)) {
      var e2a = addonToAppid(), bits = { from: e2a[old], to: e2a[value] };
      if (cause) bits.cause = cause;
      track('switch-preferred', bits);
    }
    return setPref(id, array);
  }

  // purge all empty arrays and objects from val and stores the result as `id`
  // (or deletes it, if the result was empty too)
  function saveUnlessEmpty(id, val) {
    for (var key in val)
      if (isEmpty(val[key]))
        delete val[key];
    if (!isEmpty(val))
      return setPref(id, val);
    delPref(id);
    return null;
  }

  function getJSONCodec() {
    if (getJSONCodec.codec) return getJSONCodec.codec;
    if (typeof JSON !== 'undefined' && (typeof JSON.stringify === 'function' &&
        typeof JSON.parse === 'function' && JSON.parse('"\\""') === '"' &&
        JSON.stringify('"') === '"\\""')) return getJSONCodec.codec = JSON;

    var borkedJSON = Cc['@mozilla.org/dom/json;1'].createInstance(Ci.nsIJSON);
    return getJSONCodec.codec = // nsIJSON only groks arrays or objects; wrap:
      { parse:     function(x) { return borkedJSON.decode('['+ x +']')[0]; }
      , stringify: function(x) { return borkedJSON.encode([ x ]).slice(1, -1); }
      };
  }
  function decodeJSON(json) {
    return getJSONCodec().parse(json);
  }
  function encodeJSON(obj) {
    return getJSONCodec().stringify(obj);
  }

  function openNewTab(url) {
    var uri = Cc['@mozilla.org/network/io-service;1']
      .getService(Ci.nsIIOService).newURI(url, null, null);
    return Application.activeWindow.open(uri);
  }

  // ++simpler https://developer.mozilla.org/en/Supporting_private_browsing_mode
  // (calls onChange(isNormalMode) every time we toggle between PBM and non-PBM)
  function inPrivateBrowsingMode(onChange) {
    function togglePBM(aSubject, aTopic, aData) {
      if ('private-browsing' === aTopic) onChange('enter' !== aData);
    }

    if (onChange)
      Cc['@mozilla.org/observer-service;1'].getService(Ci.nsIObserverService).
        addObserver({ observe: togglePBM }, 'private-browsing', false);

    try {
      return Cc['@mozilla.org/privatebrowsing;1']
        .getService(Ci.nsIPrivateBrowsingService).privateBrowsingEnabled;
    } catch(ex) {
      return false;
    }
  }
})('undefined' !== typeof getsmartlinks && window.getsmartlinks);
]]></script>
</overlay>
